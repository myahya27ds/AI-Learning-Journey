# -*- coding: utf-8 -*-
"""Final Script ‚Äì Perfect Calculator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NEY02V-GDwXEu0hP_nST-YwhIp7j7Dhn
"""

import math
import os
import re
import operator

# Define the filename for storing calculation history
HISTORY_FILE = "history.txt"

# ---------------- History Functions ----------------
# Function to load calculation history from the file
def load_history():
    if os.path.exists(HISTORY_FILE):
        with open(HISTORY_FILE, "r") as f:
            return f.read().splitlines()
    # Return an empty list if the history file doesn't exist
    return []

# Function to save a calculation to the history file
def save_history(calculation):
    with open(HISTORY_FILE, "a") as f:
        f.write(calculation + "\n")

# Load history when the script starts
history = load_history()

# Function to display the calculation history
def view_history():
    global history
    # Reload history to ensure it's up-to-date
    history = load_history()
    print("\n--- History ---")
    if not history:
        print("No calculations yet.")
    else:
        # Enumerate and print each history item
        for i, item in enumerate(history, 1):
            print(f"{i}. {item}")
    print("---------------------------")

# Function to clear the calculation history
def clear_history():
    global history
    history = []
    # Remove the history file
    if os.path.exists(HISTORY_FILE):
        os.remove(HISTORY_FILE)
    print("\n--- History cleared ---")
    print("="*40)

# ---------------- Input & Format Helpers ----------------
# Function to get a valid number input from the user
def get_number_input(prompt):
    while True:
        try:
            return float(input(prompt))
        except ValueError:
            print("‚ùå Error: Please enter a valid number.")

# Function to format a number for display
def format_number(num):
    if num is None: return "None"
    if isinstance(num, (int, float)):
        # Return as integer if it's a whole number, otherwise round to 6 decimal places
        return int(num) if float(num).is_integer() else round(num, 6)
    return num

# Function to format a decimal number with a specified precision
def format_decimal(num, precision=6):
    return f"{num:.{precision}f}" if not float(num).is_integer() else int(num)

# ---------------- Binary Operations ----------------
# Generic function for binary operations (e.g., +, -, *, /)
def binary_operation(op_symbol, func, name):
    print(f"\n--- {name} ---")
    a = get_number_input("First number: ")
    b = get_number_input("Second number: ")

    # Handle division and modulus by zero
    if op_symbol == "√∑" and b == 0:
        print("‚ùå Cannot divide by zero!")
        return
    if op_symbol == "%" and b == 0:
        print("‚ùå Cannot perform modulus with zero!")
        return

    # Perform the operation and format the result
    result = func(a, b)
    calculation = f"{format_number(a)} {op_symbol} {format_number(b)} = {format_decimal(result)}"
    print(calculation)
    # Save the calculation to history
    save_history(calculation)
    print("="*40)

# ---------------- Unary Operations ----------------
# Function to calculate the square root
def square_root():
    a = get_number_input("Number: ")
    # Handle negative input for square root
    if a < 0:
        print("‚ùå Cannot calculate sqrt of negative number!")
        return
    result = math.sqrt(a)
    calculation = f"‚àö{format_number(a)} = {format_decimal(result)}"
    print(calculation)
    save_history(calculation)
    print("="*40)

# Function to calculate the logarithm (base 10)
def logarithm():
    a = get_number_input("Number: ")
    # Handle non-positive input for logarithm
    if a <= 0:
        print("‚ùå Logarithm undefined for ‚â§ 0!")
        return
    result = math.log10(a)
    calculation = f"log10({format_number(a)}) = {format_decimal(result)}"
    print(calculation)
    save_history(calculation)
    print("="*40)

# ---------------- Trigonometry ----------------
# Generic function for trigonometric operations (sin, cos, tan)
def trig_function(func, name):
    choice = input("Angle in degrees or radians? (d/r): ").lower()
    if choice == "d":
        a_deg = get_number_input("Angle (degrees): ")
        # Convert degrees to radians
        a = math.radians(a_deg)
    else:
        a = get_number_input("Angle (radians): ")

    # Handle undefined tangent for angles where cosine is close to zero
    if func == math.tan and math.isclose(math.cos(a), 0, abs_tol=1e-9):
        print("‚ùå Tan undefined for this angle!")
        return

    # Perform the trigonometric calculation
    result = func(a)
    calculation = f"{name}({format_decimal(a)} rad) = {format_decimal(result)}"
    print(calculation)
    save_history(calculation)
    print("="*40)

# ---------------- Automatic Calculation ----------------
# Support for: + - * / % ^, sqrt(x), log(x), sin(x), cos(x), tan(x)
# Function to evaluate a mathematical expression entered by the user
def automatic_calculation():
    expression = input("Expression: ")
    # Define a safe dictionary of allowed functions and constants for eval()
    safe_dict = {
        "sqrt": math.sqrt,
        "log": math.log10,
        # Lambda functions for trig with optional unit handling (though not fully implemented in eval context)
        "sin": lambda x, unit="rad": math.sin(math.radians(x)) if unit == "deg" else math.sin(x),
        "cos": lambda x, unit="rad": math.cos(math.radians(x)) if unit == "deg" else math.cos(x),
        "tan": lambda x, unit="rad": math.tan(math.radians(x)) if unit == "deg" else math.tan(x),
        "pi": math.pi,
        "e": math.e,
    }

    try:
        # Evaluate the expression using eval with restricted globals and locals
        result = eval(expression, {"__builtins__": None}, safe_dict)
        calculation = f"{expression} = {format_decimal(result)}"
        print(calculation)
        save_history(calculation)
        print("="*40)
    except Exception as e:
        # Catch and print any errors during evaluation
        print(f"‚ùå Error: {e}")

# ---------------- Menu ----------------
# Dictionary mapping menu options to function calls
menu = {
    "1": ("Automatic Calculation", automatic_calculation),
    "2": ("Addition", lambda: binary_operation("+", operator.add, "Addition")),
    "3": ("Subtraction", lambda: binary_operation("-", operator.sub, "Subtraction")),
    "4": ("Multiplication", lambda: binary_operation("√ó", operator.mul, "Multiplication")),
    "5": ("Division", lambda: binary_operation("√∑", operator.truediv, "Division")),
    "6": ("Exponentiation", lambda: binary_operation("^", operator.pow, "Exponentiation")),
    "7": ("Modulus (remainder)", lambda: binary_operation("%", operator.mod, "Modulus")),
    "8": ("Square Root", square_root),
    "9": ("Logarithm (base 10)", logarithm),
    "10": ("Sin", lambda: trig_function(math.sin, "Sin")),
    "11": ("Cos", lambda: trig_function(math.cos, "Cos")),
    "12": ("Tan", lambda: trig_function(math.tan, "Tan")),
    "13": ("View History", view_history),
    "14": ("Clear History", clear_history),
}

# ---------------- Main Loop ----------------
# The main loop of the calculator program
while True:
    print("\n==== Perfect Scientific Calculator ====")
    # Print the menu options
    for key, (name, _) in menu.items():
        print(f"{key}. {name}")
    print("0. Exit")

    # Get user's menu choice
    choice = input("Choose menu: ")
    # Exit the loop if the user chooses 0
    if choice == "0":
        print("Program finished!")
        break
    # Execute the corresponding function based on the user's choice
    elif choice in menu:
        menu[choice][1]()
    else:
        print("Invalid choice!")

    # Ask if the user wants to perform another calculation (except for history options)
    if choice not in ["0", "13", "14"]:
        again = input("\nCalculate again? (y/n): ")
        if again.lower() != "y":
            print("Thanks for using the calculator üòä")
            break